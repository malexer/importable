from abc import ABCMeta, abstractmethod
import atexit
import os.path
from pathlib import Path
import shutil
import sys
import tempfile
from urllib.parse import urlparse
import zipfile

from hdfs import InsecureClient
import requests


def get_url_schema(url):
    return urlparse(url).scheme


class ImportBase(metaclass=ABCMeta):

    def __init__(self):
        self._tmp_dir = None
        self._python_path = None
        self._local_package_file = None

    def _get_temp_filename(self):
        f = tempfile.NamedTemporaryFile(dir=self._tmp_dir, delete=False)
        f.close()
        os.unlink(f.name)
        return f.name

    def _create_temp_locations(self, temp_dir=None):
        if temp_dir is not None and not os.path.exists(temp_dir):
            raise IOError('Provided temp path does not exist: %s' % temp_dir)

        self._tmp_dir = tempfile.mkdtemp(dir=temp_dir)
        self._python_path = tempfile.mkdtemp(dir=self._tmp_dir)

        self._local_package_file = self._get_temp_filename()

        atexit.register(shutil.rmtree, path=self._tmp_dir, ignore_errors=True)

    def _add_to_python_path(self, directory):
        if directory is not None and os.path.exists(directory):
            sys.path.insert(0, directory)

    @abstractmethod
    def is_mine(self, url):
        """Check if specified url should be processed by this Importer."""
        return True

    @abstractmethod
    def download(self, remote_location, local_filepath):
        pass

    @abstractmethod
    def unpack(self, source_file, destination_dir):
        pass

    def add_pkg_to_python_path(self, location):
        self._create_temp_locations()

        self.download(
            remote_location=location,
            local_filepath=self._local_package_file,
        )
        self.unpack(
            source_file=self._local_package_file,
            destination_dir=self._python_path,
        )

        self._add_to_python_path(directory=self._python_path)


class HttpMixin(ImportBase):

    def is_mine(self, url):
        scheme = get_url_schema(url)
        return super().is_mine(url) and scheme.startswith('http')

    def download(self, remote_location, local_filepath):
        r = requests.get(remote_location, stream=True)

        if r.status_code != 200:
            r.raise_for_status()

        with open(local_filepath, 'wb') as f:
            for chunk in r.iter_content(1024 * 10):
                f.write(chunk)


class HdfsMixin(ImportBase):

    @staticmethod
    def _build_namenode_url(host, port):
        url = '%s:%s' % (host, port) if port else host
        return 'http://' + url

    def is_mine(self, url):
        scheme = get_url_schema(url)
        return super().is_mine(url) and scheme == 'webhdfs'

    def download(self, remote_location, local_filepath):
        url = urlparse(remote_location)

        if not url.hostname:
            raise ValueError(
                'Hostname was not found in provided URL: %s' % remote_location)

        connect_url = self._build_namenode_url(url.hostname, url.port)
        hdfs_path = url.path

        hdfs = InsecureClient(connect_url)
        hdfs.download(hdfs_path, local_filepath)


class ZipMixin(ImportBase):

    def is_mine(self, url):
        url_path = urlparse(url).path
        return super().is_mine(url) and url_path.endswith('.zip')

    def unpack(self, source_file, destination_dir):
        if not zipfile.is_zipfile(source_file):
            raise ValueError(
                'Provided file is not a ZIP archive: %s' % source_file)

        with zipfile.ZipFile(source_file) as zf:
            zf.extractall(path=destination_dir)


class HttpZipImporter(HttpMixin, ZipMixin):
    """Regular zip file importer by arbitrary URL.

    Currenly there is a restriction: provided url should have path part
    ending with ".zip"

    Importable module should be located in the root of zip file.
    Use "GitHubHttpZipImporter" for GitHub repo download links because
    they have extra directory inside zip file.

    URL format: http(s)://<url>/<filename>.zip
    """

    def is_mine(self, url):
        return super().is_mine(url)


class GitHubHttpZipImporter(HttpZipImporter):
    """Importer for GitHub repo download links.

    It is the links generated by "Clone or download" button in GitHub UI
    i.e.: https://github.com/malexer/importable/archive/master.zip

    GitHub zip file has extra directory inside on the first level with
    format: <project name>-<branch or commit>

    URL format: http(s)://github.com/<path>/<filename>.zip
    """

    def is_mine(self, url):
        netloc = urlparse(url).netloc
        return super().is_mine(url) and 'github.com' in netloc

    def unpack(self, source_file, destination_dir):

        def we_need_to_go_deeper(dir):
            """Go +1 dir level, there should be only 1 subdirectory in
            dir.
            """
            subdirs = [f for f in Path(dir).iterdir() if f.is_dir()]
            if len(subdirs) != 1:
                raise ValueError(
                    'Unsupported format of archive from github: more than '
                    'one first-level sub-directory inside.')
            return str(subdirs[0])

        super().unpack(source_file, destination_dir)
        self._python_path = we_need_to_go_deeper(self._python_path)


class HdfsZipImporter(HdfsMixin, ZipMixin):
    """Regular zip file importer by HDFS URL.

    Currenly there is a restriction: provided url should have path part
    ending with ".zip"

    Importable module should be located in the root of zip file.

    URL format: webhdfs://<host>:<port>/<path>/<filename>.zip
    """

    def is_mine(self, url):
        return super().is_mine(url)


# Note: order matters - check for matching specific importer will be
# applied in this order
IMPORTERS = (
    GitHubHttpZipImporter,
    HttpZipImporter,
    HdfsZipImporter,
)


def importable(url):
    """Add to python path zipped module provided by the ``url``.

    Remote URL will be downloaded, unzipped and added to python path.

    .. note::
        Module will be only added to python path. It will be possible
        to import it afterwards.

    :type url: str
    :param url: HTTP url of zipped python package
    """
    if not isinstance(url, str):
        msg = "importable() argument must be a string, not '%s'"
        raise TypeError(msg % type(url).__name__)

    for cls in IMPORTERS:
        importer = cls()
        if importer.is_mine(url):
            return importer.add_pkg_to_python_path(url)

    raise ValueError('Unsupported url format: %s' % url)
